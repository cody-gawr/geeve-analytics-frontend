import { Notation } from './model';
import { AffinityCalculation } from './helper/affinity-calculation-strategy';
import { Mask } from './helper/mask';
export declare class MaskedTextChangedListener {
    protected readonly primaryFormat: String;
    private field;
    protected readonly listener?: MaskedTextChangedListener.ValueListener;
    protected readonly affineFormats: ReadonlyArray<String>;
    protected readonly customNotations: ReadonlyArray<Notation>;
    protected readonly affinityCalculationStrategy: AffinityCalculation;
    protected readonly autocomplete: boolean;
    private readonly primaryMask;
    private afterText;
    private caretPosition;
    constructor(primaryFormat: String, field: HTMLInputElement, listener?: MaskedTextChangedListener.ValueListener, affineFormats?: ReadonlyArray<String>, customNotations?: ReadonlyArray<Notation>, affinityCalculationStrategy?: AffinityCalculation, autocomplete?: boolean);
    static installOn(primaryFormat: String, field: HTMLInputElement, listener?: MaskedTextChangedListener.ValueListener, affineFormats?: ReadonlyArray<String>, customNotations?: ReadonlyArray<Notation>, affinityCalculationStrategy?: AffinityCalculation, autocomplete?: boolean): MaskedTextChangedListener;
    placeholder: () => String;
    acceptableTextLength: () => number;
    totalTextLength: () => number;
    totalValueLength: () => number;
    setText(text: String): Mask.Result | null;
    private _setText;
    private pickMask;
    private calculateAffinity;
    private addEvents;
    private onFocusChange;
    private onTextChanged;
}
export declare namespace MaskedTextChangedListener {
    class ValueListener {
        onTextChanged(maskFilled: boolean, extractedValue: String, formattedValue: String): any;
    }
}
