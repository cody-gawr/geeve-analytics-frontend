import { __decorate, __param, __assign, __read } from 'tslib';
import { Inject, PLATFORM_ID, Injectable, InjectionToken, EventEmitter, Output, ViewChild, Input, Component, NgModule } from '@angular/core';
import { isPlatformBrowser, isPlatformServer } from '@angular/common';
import { BehaviorSubject, from, combineLatest } from 'rxjs';
import { filter, first, map, switchMap } from 'rxjs/operators';

var WindowRef = /** @class */ (function () {
    function WindowRef(platformId) {
        this.platformId = platformId;
    }
    WindowRef.prototype.getNativeWindow = function () {
        if (isPlatformBrowser(this.platformId)) {
            return window;
        }
        return {};
    };
    WindowRef.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: Inject, args: [PLATFORM_ID,] }] }
    ]; };
    WindowRef = __decorate([
        Injectable(),
        __param(0, Inject(PLATFORM_ID))
    ], WindowRef);
    return WindowRef;
}());

var DocumentRef = /** @class */ (function () {
    function DocumentRef(platformId) {
        this.platformId = platformId;
    }
    DocumentRef.prototype.getNativeDocument = function () {
        if (isPlatformBrowser(this.platformId)) {
            return document;
        }
        return {};
    };
    DocumentRef.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: Inject, args: [PLATFORM_ID,] }] }
    ]; };
    DocumentRef = __decorate([
        Injectable(),
        __param(0, Inject(PLATFORM_ID))
    ], DocumentRef);
    return DocumentRef;
}());

var LazyStripeAPILoader = /** @class */ (function () {
    function LazyStripeAPILoader(platformId, window, document) {
        this.platformId = platformId;
        this.window = window;
        this.document = document;
        this.status = new BehaviorSubject({
            error: false,
            loaded: false,
            loading: false
        });
    }
    LazyStripeAPILoader.prototype.asStream = function () {
        this.load();
        return this.status.asObservable();
    };
    LazyStripeAPILoader.prototype.isReady = function () {
        return this.status.getValue().loaded;
    };
    LazyStripeAPILoader.prototype.load = function () {
        var _this = this;
        if (isPlatformServer(this.platformId)) {
            return;
        }
        var status = this.status.getValue();
        if (this.window.getNativeWindow().hasOwnProperty('Stripe')) {
            this.status.next({
                error: false,
                loaded: true,
                loading: false
            });
        }
        else if (!status.loaded && !status.loading) {
            this.status.next(__assign(__assign({}, status), { loading: true }));
            var script = this.document.getNativeDocument().createElement('script');
            script.type = 'text/javascript';
            script.async = true;
            script.defer = true;
            script.src = 'https://js.stripe.com/v3/';
            script.onload = function () {
                _this.status.next({
                    error: false,
                    loaded: true,
                    loading: false
                });
            };
            script.onerror = function () {
                _this.status.next({
                    error: true,
                    loaded: false,
                    loading: false
                });
            };
            this.document.getNativeDocument().body.appendChild(script);
        }
    };
    LazyStripeAPILoader.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: Inject, args: [PLATFORM_ID,] }] },
        { type: WindowRef },
        { type: DocumentRef }
    ]; };
    LazyStripeAPILoader = __decorate([
        Injectable(),
        __param(0, Inject(PLATFORM_ID))
    ], LazyStripeAPILoader);
    return LazyStripeAPILoader;
}());

var STRIPE_PUBLISHABLE_KEY = new InjectionToken('Stripe Publishable Key');
var STRIPE_OPTIONS = new InjectionToken('Stripe Options');

function isSourceData(sourceData) {
    return 'type' in sourceData;
}

function isAccount(account) {
    return account === 'account';
}
function isAccountData(accountData) {
    return accountData.legal_entity || accountData.tos_shown_and_accepted;
}
function isBankAccount(account) {
    return account === 'bank_account';
}
function isBankAccountData(bankAccountData) {
    return ('country' in bankAccountData &&
        'currency' in bankAccountData &&
        'routing_number' in bankAccountData &&
        'account_number' in bankAccountData &&
        (bankAccountData.account_holder_type === 'individual' ||
            bankAccountData.account_holder_type === 'company' ||
            bankAccountData.account_holder_type === undefined));
}
function isPii(pii) {
    return pii === 'pii';
}
function isPiiData(piiData) {
    return 'personal_id_number' in piiData;
}

function isHandleCardPaymentOptions(handleCardPaymentOptions) {
    return 'type' in handleCardPaymentOptions;
}
function isPaymentMethodData(paymentMethodData) {
    return paymentMethodData && 'type' in paymentMethodData;
}

var StripeInstance = /** @class */ (function () {
    function StripeInstance(loader, window, key, options) {
        var _this = this;
        this.loader = loader;
        this.window = window;
        this.key = key;
        this.options = options;
        this.stripe$ = new BehaviorSubject(undefined);
        this.loader
            .asStream()
            .pipe(filter(function (status) { return status.loaded === true; }), first(), map(function () { return _this.window.getNativeWindow().Stripe; }))
            .subscribe(function (Stripe) {
            var stripe = _this.options
                ? Stripe(_this.key, _this.options)
                : Stripe(_this.key);
            _this.stripe$.next(stripe);
        });
    }
    StripeInstance.prototype.getInstance = function () {
        return this.stripe$.getValue();
    };
    StripeInstance.prototype.elements = function (options) {
        return this.stripe$.asObservable().pipe(filter(function (stripe) { return Boolean(stripe); }), map(function (stripe) { return stripe.elements(options); }), first());
    };
    StripeInstance.prototype.createToken = function (a, b) {
        return this.stripe$.asObservable().pipe(filter(function (stripe) { return Boolean(stripe); }), switchMap(function (s) {
            var stripe = s;
            if (isAccount(a) && isAccountData(b)) {
                return from(stripe.createToken(a, b));
            }
            else if (isBankAccount(a) && isBankAccountData(b)) {
                return from(stripe.createToken(a, b));
            }
            else if (isPii(a) && isPiiData(b)) {
                return from(stripe.createToken(a, b));
            }
            else {
                return from(stripe.createToken(a, b));
            }
        }), first());
    };
    StripeInstance.prototype.createSource = function (a, b) {
        return this.stripe$.asObservable().pipe(filter(function (stripe) { return Boolean(stripe); }), switchMap(function (s) {
            var stripe = s;
            if (isSourceData(a)) {
                return from(stripe.createSource(a));
            }
            return from(stripe.createSource(a, b));
        }), first());
    };
    StripeInstance.prototype.retrieveSource = function (source) {
        return this.stripe$.asObservable().pipe(filter(function (stripe) { return Boolean(stripe); }), switchMap(function (s) {
            var stripe = s;
            return from(stripe.retrieveSource(source));
        }), first());
    };
    StripeInstance.prototype.paymentRequest = function (options) {
        var stripe = this.getInstance();
        if (stripe) {
            return stripe.paymentRequest(options);
        }
        return undefined;
    };
    StripeInstance.prototype.handleCardPayment = function (a, b, c) {
        return this.stripe$.asObservable().pipe(filter(function (stripe) { return Boolean(stripe); }), switchMap(function (s) {
            var stripe = s;
            if (isHandleCardPaymentOptions(b)) {
                return from(stripe.handleCardPayment(a, b));
            }
            return from(stripe.handleCardPayment(a, b, c));
        }));
    };
    StripeInstance.prototype.handleCardAction = function (a) {
        return this.stripe$.asObservable().pipe(filter(function (stripe) { return Boolean(stripe); }), switchMap(function (s) {
            var stripe = s;
            return from(stripe.handleCardAction(a));
        }));
    };
    StripeInstance.prototype.confirmPaymentIntent = function (a, b) {
        return this.stripe$.asObservable().pipe(filter(function (stripe) { return Boolean(stripe); }), switchMap(function (s) {
            var stripe = s;
            return from(stripe.confirmPaymentIntent(a, b));
        }));
    };
    StripeInstance.prototype.createPaymentMethod = function (a, b, c) {
        return this.stripe$.asObservable().pipe(filter(function (stripe) { return Boolean(stripe); }), switchMap(function (s) {
            var stripe = s;
            return from(stripe.createPaymentMethod(a, b, c));
        }), first());
    };
    StripeInstance.prototype.handleCardSetup = function (a, b, c) {
        return this.stripe$.asObservable().pipe(filter(function (stripe) { return Boolean(stripe); }), switchMap(function (s) {
            var stripe = s;
            if (isPaymentMethodData(c)) {
                return from(stripe.handleCardSetup(a, b, c));
            }
            return from(stripe.handleCardSetup(a, b));
        }));
    };
    return StripeInstance;
}());

var StripeService = /** @class */ (function () {
    function StripeService(key, options, loader, window) {
        this.key = key;
        this.options = options;
        this.loader = loader;
        this.window = window;
        if (key) {
            this.stripe = new StripeInstance(this.loader, this.window, key, options);
        }
    }
    StripeService.prototype.getStripeReference = function () {
        var _this = this;
        return this.loader.asStream().pipe(filter(function (status) { return status.loaded === true; }), map(function () { return _this.window.getNativeWindow().Stripe; }));
    };
    StripeService.prototype.getInstance = function () {
        return this.stripe.getInstance();
    };
    StripeService.prototype.setKey = function (key, options) {
        return this.changeKey(key, options);
    };
    StripeService.prototype.changeKey = function (key, options) {
        this.stripe = new StripeInstance(this.loader, this.window, key, options);
        return this.stripe;
    };
    StripeService.prototype.elements = function (options) {
        return this.stripe.elements(options);
    };
    StripeService.prototype.createToken = function (a, b) {
        return this.stripe.createToken(a, b);
    };
    StripeService.prototype.createSource = function (a, b) {
        return this.stripe.createSource(a, b);
    };
    StripeService.prototype.retrieveSource = function (source) {
        return this.stripe.retrieveSource(source);
    };
    StripeService.prototype.paymentRequest = function (options) {
        return this.stripe.paymentRequest(options);
    };
    StripeService.prototype.handleCardPayment = function (a, b, c) {
        return this.stripe.handleCardPayment(a, b, c);
    };
    StripeService.prototype.handleCardAction = function (a) {
        return this.stripe.handleCardAction(a);
    };
    StripeService.prototype.createPaymentMethod = function (a, b, c) {
        return this.stripe.createPaymentMethod(a, b, c);
    };
    StripeService.prototype.confirmPaymentIntent = function (a, b) {
        return this.stripe.confirmPaymentIntent(a, b);
    };
    StripeService.prototype.handleCardSetup = function (a, b, c) {
        return this.stripe.handleCardSetup(a, b, c);
    };
    StripeService.ctorParameters = function () { return [
        { type: String, decorators: [{ type: Inject, args: [STRIPE_PUBLISHABLE_KEY,] }] },
        { type: undefined, decorators: [{ type: Inject, args: [STRIPE_OPTIONS,] }] },
        { type: LazyStripeAPILoader },
        { type: WindowRef }
    ]; };
    StripeService = __decorate([
        Injectable(),
        __param(0, Inject(STRIPE_PUBLISHABLE_KEY)),
        __param(1, Inject(STRIPE_OPTIONS))
    ], StripeService);
    return StripeService;
}());

var StripeFactoryService = /** @class */ (function () {
    function StripeFactoryService(baseKey, baseOptions, loader, window) {
        this.baseKey = baseKey;
        this.baseOptions = baseOptions;
        this.loader = loader;
        this.window = window;
    }
    StripeFactoryService.prototype.create = function (key, options) {
        return new StripeInstance(this.loader, this.window, key, options);
    };
    StripeFactoryService.ctorParameters = function () { return [
        { type: String, decorators: [{ type: Inject, args: [STRIPE_PUBLISHABLE_KEY,] }] },
        { type: String, decorators: [{ type: Inject, args: [STRIPE_OPTIONS,] }] },
        { type: LazyStripeAPILoader },
        { type: WindowRef }
    ]; };
    StripeFactoryService = __decorate([
        Injectable(),
        __param(0, Inject(STRIPE_PUBLISHABLE_KEY)),
        __param(1, Inject(STRIPE_OPTIONS))
    ], StripeFactoryService);
    return StripeFactoryService;
}());

var StripeCardComponent = /** @class */ (function () {
    function StripeCardComponent(stripeService) {
        this.stripeService = stripeService;
        this.card = new EventEmitter();
        // tslint:disable-next-line:no-output-on-prefix
        this.on = new EventEmitter();
        this.options$ = new BehaviorSubject({});
        this.elementsOptions$ = new BehaviorSubject({});
        this.stripe$ = new BehaviorSubject(null);
    }
    Object.defineProperty(StripeCardComponent.prototype, "options", {
        set: function (optionsIn) {
            this.options$.next(optionsIn);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(StripeCardComponent.prototype, "elementsOptions", {
        set: function (optionsIn) {
            this.elementsOptions$.next(optionsIn);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(StripeCardComponent.prototype, "stripe", {
        set: function (stripeIn) {
            this.stripe$.next(stripeIn);
        },
        enumerable: true,
        configurable: true
    });
    StripeCardComponent.prototype.ngAfterViewInit = function () {
        var _this = this;
        var elements$ = combineLatest(this.elementsOptions$.asObservable(), this.stripe$.asObservable()).pipe(switchMap(function (_a) {
            var _b = __read(_a, 2), options = _b[0], stripe = _b[1];
            if (stripe) {
                if (Object.keys(options).length > 0) {
                    return stripe.elements(options);
                }
                return stripe.elements();
            }
            else {
                if (Object.keys(options).length > 0) {
                    return _this.stripeService.elements(options);
                }
                return _this.stripeService.elements();
            }
        }));
        combineLatest(elements$, this.options$.asObservable().pipe(filter(function (options) { return Boolean(options); }))).subscribe(function (_a) {
            var _b = __read(_a, 2), elements = _b[0], options = _b[1];
            _this.element = elements.create('card', options);
            _this.element.on('blur', function (ev) {
                return _this.on.emit({
                    event: ev,
                    type: 'blur'
                });
            });
            _this.element.on('change', function (ev) {
                return _this.on.emit({
                    event: ev,
                    type: 'change'
                });
            });
            _this.element.on('click', function (ev) {
                return _this.on.emit({
                    event: ev,
                    type: 'click'
                });
            });
            _this.element.on('focus', function (ev) {
                return _this.on.emit({
                    event: ev,
                    type: 'focus'
                });
            });
            _this.element.on('ready', function (ev) {
                return _this.on.emit({
                    event: ev,
                    type: 'ready'
                });
            });
            _this.element.mount(_this.stripeCard.nativeElement);
            _this.card.emit(_this.element);
        });
    };
    StripeCardComponent.prototype.getCard = function () {
        return this.element;
    };
    StripeCardComponent.ctorParameters = function () { return [
        { type: StripeService }
    ]; };
    __decorate([
        Output()
    ], StripeCardComponent.prototype, "card", void 0);
    __decorate([
        Output()
    ], StripeCardComponent.prototype, "on", void 0);
    __decorate([
        ViewChild('stripeCard')
    ], StripeCardComponent.prototype, "stripeCard", void 0);
    __decorate([
        Input()
    ], StripeCardComponent.prototype, "options", null);
    __decorate([
        Input()
    ], StripeCardComponent.prototype, "elementsOptions", null);
    __decorate([
        Input()
    ], StripeCardComponent.prototype, "stripe", null);
    StripeCardComponent = __decorate([
        Component({
            selector: 'ngx-stripe-card',
            template: "\n    <div class=\"field\" #stripeCard></div>\n  "
        })
    ], StripeCardComponent);
    return StripeCardComponent;
}());

var NgxStripeModule = /** @class */ (function () {
    function NgxStripeModule() {
    }
    NgxStripeModule_1 = NgxStripeModule;
    NgxStripeModule.forRoot = function (publishableKey, options) {
        return {
            ngModule: NgxStripeModule_1,
            providers: [
                LazyStripeAPILoader,
                StripeService,
                StripeFactoryService,
                WindowRef,
                DocumentRef,
                {
                    provide: STRIPE_PUBLISHABLE_KEY,
                    useValue: publishableKey
                },
                {
                    provide: STRIPE_OPTIONS,
                    useValue: options
                }
            ]
        };
    };
    NgxStripeModule.forChild = function (publishableKey, options) {
        return {
            ngModule: NgxStripeModule_1,
            providers: [
                LazyStripeAPILoader,
                StripeService,
                StripeFactoryService,
                WindowRef,
                DocumentRef,
                {
                    provide: STRIPE_PUBLISHABLE_KEY,
                    useValue: publishableKey
                },
                {
                    provide: STRIPE_OPTIONS,
                    useValue: options
                }
            ]
        };
    };
    var NgxStripeModule_1;
    NgxStripeModule = NgxStripeModule_1 = __decorate([
        NgModule({
            declarations: [StripeCardComponent],
            exports: [StripeCardComponent]
        })
    ], NgxStripeModule);
    return NgxStripeModule;
}());

/*
 * Public API Surface of ngx-stripe
 */

/**
 * Generated bundle index. Do not edit.
 */

export { DocumentRef, LazyStripeAPILoader, NgxStripeModule, STRIPE_OPTIONS, STRIPE_PUBLISHABLE_KEY, StripeCardComponent, StripeFactoryService, StripeInstance, StripeService, WindowRef, isBankAccount, isBankAccountData, isPii, isPiiData, isSourceData };
//# sourceMappingURL=ngx-stripe.js.map
