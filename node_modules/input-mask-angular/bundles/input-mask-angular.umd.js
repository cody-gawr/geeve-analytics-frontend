(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('ts-input-mask')) :
    typeof define === 'function' && define.amd ? define('input-mask-angular', ['exports', '@angular/core', 'ts-input-mask'], factory) :
    (global = global || self, factory(global['input-mask-angular'] = {}, global.ng.core, global.tsInputMask));
}(this, (function (exports, core, tsInputMask) { 'use strict';

    var InputMaskOptions = /** @class */ (function () {
        function InputMaskOptions(affineFormats, customNotations, affinityCalculationStrategy, autocomplete) {
            if (affineFormats === void 0) { affineFormats = []; }
            if (customNotations === void 0) { customNotations = []; }
            if (affinityCalculationStrategy === void 0) { affinityCalculationStrategy = new tsInputMask.AffinityCalculation(tsInputMask.AffinityCalculationStrategy.WHOLE_STRING); }
            if (autocomplete === void 0) { autocomplete = true; }
            this.affineFormats = affineFormats;
            this.customNotations = customNotations;
            this.affinityCalculationStrategy = affinityCalculationStrategy;
            this.autocomplete = autocomplete;
        }
        return InputMaskOptions;
    }());

    var InputMaskAngularDirective = /** @class */ (function () {
        function InputMaskAngularDirective(elementRef, renderer) {
            this.elementRef = elementRef;
            this.renderer = renderer;
            this.maskFilled = new core.EventEmitter();
            this.extractedValue = new core.EventEmitter();
            this.formattedText = new core.EventEmitter();
            this.placeholder = new core.EventEmitter();
            this._options = new InputMaskOptions();
        }
        Object.defineProperty(InputMaskAngularDirective.prototype, "value", {
            set: function (value) {
                this._value = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(InputMaskAngularDirective.prototype, "primaryFormat", {
            set: function (value) {
                this._primaryFormat = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(InputMaskAngularDirective.prototype, "options", {
            set: function (value) {
                this._options = value;
            },
            enumerable: true,
            configurable: true
        });
        InputMaskAngularDirective.prototype.ngOnInit = function () {
            this.setupListener(this.elementRef.nativeElement);
        };
        InputMaskAngularDirective.prototype.setupListener = function (input) {
            var _this = this;
            if (!!this._primaryFormat) {
                var emitChanges_1 = function (maskFilled, extractedValue, formattedText) {
                    _this.maskFilled.emit(maskFilled);
                    _this.extractedValue.emit(extractedValue);
                    _this.formattedText.emit(formattedText);
                };
                var listener = tsInputMask.MaskedTextChangedListener.installOn(this._primaryFormat, input, new /** @class */ (function () {
                    function class_1() {
                    }
                    class_1.prototype.onTextChanged = function (maskFilled, extractedValue, formattedText) {
                        emitChanges_1(maskFilled, extractedValue, formattedText);
                    };
                    return class_1;
                }())(), this._options.affineFormats, this._options.customNotations, this._options.affinityCalculationStrategy, this._options.autocomplete);
                this.renderer.setProperty(input, 'placeholder', String(listener.placeholder()));
                if (!!this._value) {
                    listener.setText(this._value);
                }
                this.placeholder.emit(String(listener.placeholder()));
            }
            else {
                input.addEventListener('input', function () {
                    _this.extractedValue.emit(input.value);
                });
            }
        };
        /** @nocollapse */ InputMaskAngularDirective.ɵfac = function InputMaskAngularDirective_Factory(t) { return new (t || InputMaskAngularDirective)(core["ɵɵdirectiveInject"](core.ElementRef), core["ɵɵdirectiveInject"](core.Renderer2)); };
        /** @nocollapse */ InputMaskAngularDirective.ɵdir = core["ɵɵdefineDirective"]({ type: InputMaskAngularDirective, selectors: [["input", "mask", ""]], inputs: { value: "value", primaryFormat: ["mask", "primaryFormat"], options: "options" }, outputs: { maskFilled: "maskFilled", extractedValue: "extractedValue", formattedText: "formattedText", placeholder: "placeholder" } });
        return InputMaskAngularDirective;
    }());
    /*@__PURE__*/ (function () { core["ɵsetClassMetadata"](InputMaskAngularDirective, [{
            type: core.Directive,
            args: [{
                    selector: 'input[mask]'
                }]
        }], function () { return [{ type: core.ElementRef }, { type: core.Renderer2 }]; }, { maskFilled: [{
                type: core.Output
            }], extractedValue: [{
                type: core.Output
            }], formattedText: [{
                type: core.Output
            }], placeholder: [{
                type: core.Output
            }], value: [{
                type: core.Input,
                args: ['value']
            }], primaryFormat: [{
                type: core.Input,
                args: ['mask']
            }], options: [{
                type: core.Input,
                args: ['options']
            }] }); })();

    var InputMaskAngularPipe = /** @class */ (function () {
        function InputMaskAngularPipe() {
        }
        InputMaskAngularPipe.prototype.transform = function (value, primaryFormat, customNotations) {
            if (customNotations === void 0) { customNotations = []; }
            if (!!primaryFormat) {
                var mask = tsInputMask.Mask.getOrCreate(primaryFormat, customNotations);
                var stringLength = value.length;
                var result = mask.apply(new tsInputMask.CaretString(value, stringLength), false);
                return String(result.formattedText.string);
            }
            return value;
        };
        /** @nocollapse */ InputMaskAngularPipe.ɵfac = function InputMaskAngularPipe_Factory(t) { return new (t || InputMaskAngularPipe)(); };
        /** @nocollapse */ InputMaskAngularPipe.ɵpipe = core["ɵɵdefinePipe"]({ name: "mask", type: InputMaskAngularPipe, pure: true });
        return InputMaskAngularPipe;
    }());
    /*@__PURE__*/ (function () { core["ɵsetClassMetadata"](InputMaskAngularPipe, [{
            type: core.Pipe,
            args: [{
                    name: 'mask'
                }]
        }], null, null); })();

    var InputMaskAngularModule = /** @class */ (function () {
        function InputMaskAngularModule() {
        }
        /** @nocollapse */ InputMaskAngularModule.ɵmod = core["ɵɵdefineNgModule"]({ type: InputMaskAngularModule });
        /** @nocollapse */ InputMaskAngularModule.ɵinj = core["ɵɵdefineInjector"]({ factory: function InputMaskAngularModule_Factory(t) { return new (t || InputMaskAngularModule)(); } });
        return InputMaskAngularModule;
    }());
    (function () { (typeof ngJitMode === "undefined" || ngJitMode) && core["ɵɵsetNgModuleScope"](InputMaskAngularModule, { declarations: [InputMaskAngularDirective, InputMaskAngularPipe], exports: [InputMaskAngularDirective, InputMaskAngularPipe] }); })();
    /*@__PURE__*/ (function () { core["ɵsetClassMetadata"](InputMaskAngularModule, [{
            type: core.NgModule,
            args: [{
                    declarations: [InputMaskAngularDirective, InputMaskAngularPipe],
                    exports: [InputMaskAngularDirective, InputMaskAngularPipe]
                }]
        }], null, null); })();

    exports.InputMaskAngularDirective = InputMaskAngularDirective;
    exports.InputMaskAngularModule = InputMaskAngularModule;
    exports.InputMaskAngularPipe = InputMaskAngularPipe;
    exports.InputMaskOptions = InputMaskOptions;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=input-mask-angular.umd.js.map
