import { EventEmitter, ɵɵdirectiveInject, ElementRef, Renderer2, ɵɵdefineDirective, ɵsetClassMetadata, Directive, Output, Input, ɵɵdefinePipe, Pipe, ɵɵdefineNgModule, ɵɵdefineInjector, ɵɵsetNgModuleScope, NgModule } from '@angular/core';
import { AffinityCalculation, AffinityCalculationStrategy, MaskedTextChangedListener, Mask, CaretString } from 'ts-input-mask';

var InputMaskOptions = /** @class */ (function () {
    function InputMaskOptions(affineFormats, customNotations, affinityCalculationStrategy, autocomplete) {
        if (affineFormats === void 0) { affineFormats = []; }
        if (customNotations === void 0) { customNotations = []; }
        if (affinityCalculationStrategy === void 0) { affinityCalculationStrategy = new AffinityCalculation(AffinityCalculationStrategy.WHOLE_STRING); }
        if (autocomplete === void 0) { autocomplete = true; }
        this.affineFormats = affineFormats;
        this.customNotations = customNotations;
        this.affinityCalculationStrategy = affinityCalculationStrategy;
        this.autocomplete = autocomplete;
    }
    return InputMaskOptions;
}());

var InputMaskAngularDirective = /** @class */ (function () {
    function InputMaskAngularDirective(elementRef, renderer) {
        this.elementRef = elementRef;
        this.renderer = renderer;
        this.maskFilled = new EventEmitter();
        this.extractedValue = new EventEmitter();
        this.formattedText = new EventEmitter();
        this.placeholder = new EventEmitter();
        this._options = new InputMaskOptions();
    }
    Object.defineProperty(InputMaskAngularDirective.prototype, "value", {
        set: function (value) {
            this._value = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(InputMaskAngularDirective.prototype, "primaryFormat", {
        set: function (value) {
            this._primaryFormat = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(InputMaskAngularDirective.prototype, "options", {
        set: function (value) {
            this._options = value;
        },
        enumerable: true,
        configurable: true
    });
    InputMaskAngularDirective.prototype.ngOnInit = function () {
        this.setupListener(this.elementRef.nativeElement);
    };
    InputMaskAngularDirective.prototype.setupListener = function (input) {
        var _this = this;
        if (!!this._primaryFormat) {
            var emitChanges_1 = function (maskFilled, extractedValue, formattedText) {
                _this.maskFilled.emit(maskFilled);
                _this.extractedValue.emit(extractedValue);
                _this.formattedText.emit(formattedText);
            };
            var listener = MaskedTextChangedListener.installOn(this._primaryFormat, input, new /** @class */ (function () {
                function class_1() {
                }
                class_1.prototype.onTextChanged = function (maskFilled, extractedValue, formattedText) {
                    emitChanges_1(maskFilled, extractedValue, formattedText);
                };
                return class_1;
            }())(), this._options.affineFormats, this._options.customNotations, this._options.affinityCalculationStrategy, this._options.autocomplete);
            this.renderer.setProperty(input, 'placeholder', String(listener.placeholder()));
            if (!!this._value) {
                listener.setText(this._value);
            }
            this.placeholder.emit(String(listener.placeholder()));
        }
        else {
            input.addEventListener('input', function () {
                _this.extractedValue.emit(input.value);
            });
        }
    };
    /** @nocollapse */ InputMaskAngularDirective.ɵfac = function InputMaskAngularDirective_Factory(t) { return new (t || InputMaskAngularDirective)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Renderer2)); };
    /** @nocollapse */ InputMaskAngularDirective.ɵdir = ɵɵdefineDirective({ type: InputMaskAngularDirective, selectors: [["input", "mask", ""]], inputs: { value: "value", primaryFormat: ["mask", "primaryFormat"], options: "options" }, outputs: { maskFilled: "maskFilled", extractedValue: "extractedValue", formattedText: "formattedText", placeholder: "placeholder" } });
    return InputMaskAngularDirective;
}());
/*@__PURE__*/ (function () { ɵsetClassMetadata(InputMaskAngularDirective, [{
        type: Directive,
        args: [{
                selector: 'input[mask]'
            }]
    }], function () { return [{ type: ElementRef }, { type: Renderer2 }]; }, { maskFilled: [{
            type: Output
        }], extractedValue: [{
            type: Output
        }], formattedText: [{
            type: Output
        }], placeholder: [{
            type: Output
        }], value: [{
            type: Input,
            args: ['value']
        }], primaryFormat: [{
            type: Input,
            args: ['mask']
        }], options: [{
            type: Input,
            args: ['options']
        }] }); })();

var InputMaskAngularPipe = /** @class */ (function () {
    function InputMaskAngularPipe() {
    }
    InputMaskAngularPipe.prototype.transform = function (value, primaryFormat, customNotations) {
        if (customNotations === void 0) { customNotations = []; }
        if (!!primaryFormat) {
            var mask = Mask.getOrCreate(primaryFormat, customNotations);
            var stringLength = value.length;
            var result = mask.apply(new CaretString(value, stringLength), false);
            return String(result.formattedText.string);
        }
        return value;
    };
    /** @nocollapse */ InputMaskAngularPipe.ɵfac = function InputMaskAngularPipe_Factory(t) { return new (t || InputMaskAngularPipe)(); };
    /** @nocollapse */ InputMaskAngularPipe.ɵpipe = ɵɵdefinePipe({ name: "mask", type: InputMaskAngularPipe, pure: true });
    return InputMaskAngularPipe;
}());
/*@__PURE__*/ (function () { ɵsetClassMetadata(InputMaskAngularPipe, [{
        type: Pipe,
        args: [{
                name: 'mask'
            }]
    }], null, null); })();

var InputMaskAngularModule = /** @class */ (function () {
    function InputMaskAngularModule() {
    }
    /** @nocollapse */ InputMaskAngularModule.ɵmod = ɵɵdefineNgModule({ type: InputMaskAngularModule });
    /** @nocollapse */ InputMaskAngularModule.ɵinj = ɵɵdefineInjector({ factory: function InputMaskAngularModule_Factory(t) { return new (t || InputMaskAngularModule)(); } });
    return InputMaskAngularModule;
}());
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵɵsetNgModuleScope(InputMaskAngularModule, { declarations: [InputMaskAngularDirective, InputMaskAngularPipe], exports: [InputMaskAngularDirective, InputMaskAngularPipe] }); })();
/*@__PURE__*/ (function () { ɵsetClassMetadata(InputMaskAngularModule, [{
        type: NgModule,
        args: [{
                declarations: [InputMaskAngularDirective, InputMaskAngularPipe],
                exports: [InputMaskAngularDirective, InputMaskAngularPipe]
            }]
    }], null, null); })();

/*
 * Public API Surface of input-mask-angular
 */

/**
 * Generated bundle index. Do not edit.
 */

export { InputMaskAngularDirective, InputMaskAngularModule, InputMaskAngularPipe, InputMaskOptions };
//# sourceMappingURL=input-mask-angular.js.map
